% Основные настройки программы
N = 10; % Количество частиц
L_x = 0.5; % [м] Размер области по оси x
L_y = 0.5; % [м] Размер области по оси y
lambda = 0.03; % [м] Дебаевский радиус
r_m = 0.1; % [м] Радиус обрезки
dt = 1; % [с] Шаг времени
T_max = 2; % [с] Максимальное время симуляции
N_step = round(T_max / dt); % Количество шагов симуляции
f = @(q1, q2, m, r) - q1 .* q2 ./ (r.^3) .* (1 - exp(-r / lambda) .* (1 + r / lambda)) / m; % Функция, считающая ускорение

% Создание массивов, описывающих частицы
% Массивы лучше создать сразу, после чего менять их содержимое и не менять
% размер - так быстрее
pos_all = zeros(N, 2);
spd_all = zeros(N, 2);
acc_all = zeros(N, 2);
dacc = zeros(N, 2);
dacc_mod = zeros(N, 1);
q_all = zeros(N, 1);
m_all = zeros(N, 1);
dpos = zeros(N, 2);
dr_all = zeros(N, 1);
decs = zeros(N, 2);

% Генерация случайных начальных позиций
pos_all(:, 1) = L_x * rand(N, 1);
pos_all(:, 2) = L_y * rand(N, 1);
% Генерацию начальных скоростей, зарядов и масс надо сделать, причем правильным
% образом
% Для генерации масс и зарядов сейчас стоит заглушка
q_all = ones(N, 1);
m_all = ones(N, 1);

T_curr = 0;

% Основной цикл моделирования
for i=1:N_step
    for j=1:N
        % Выделяем координаты и заряд j-той частицы
        x_curr = pos_all(j, 1);
        y_curr = pos_all(j, 2);
        q_curr = q_all(j);
        m_curr = m_all(j);
        % Считаем перемещения остальных частиц относительно j-той
        dpos(:, 1) = pos_all(:, 1) - x_curr;
        dpos(:, 2) = pos_all(:, 2) - y_curr;
        % Формируем матрицу решений по учитыванию взаимодействий
        decs = (abs(dpos) <= r_m);
        decs(:, 1) = (decs(:, 1) & decs(:, 2));
        decs(:, 2) = (decs(:, 1) & decs(:, 2));
        % Обновляем матрицу dpos так, чтобы в ней остались только те
        % строки, взаимодействие которых надо учитывать
        dpos = dpos.*decs;
        % Считаем квадраты расстояний, после чего их обрезаем и считаем
        % расстояния
        dr_all = dpos(:, 1).^2 + dpos(:, 2).^2;
        dr_all(dr_all > r_m^2) = 0;
        dr_all = dr_all.^(1/2);
        % Считаем множитель ускорения и заменяем NaN на нули
        dacc_mod = f(q_curr, q_all, m_curr, dr_all);
        dacc_mod(isnan(dacc_mod)) = 0;
        % Считаем ускорение от каждой частицы
        dacc(:, 1) = dpos(:, 1) .* dacc_mod;
        dacc(:, 2) = dpos(:, 2) .* dacc_mod;
        % Считаем суммарное ускорение данной частицы
        acc_all(j, 1) = sum(dacc(:, 1));
        acc_all(j, 2) = sum(dacc(:, 2));
    end
    % Интегрирование позиций и скоростей с учетом периодических граничных
    % условий
    pos_all = pos_all + spd_all * dt + acc_all * dt^2 / 2;
    pos_all(:, 1) = mod(pos_all(:, 1), L_x);
    pos_all(:, 2) = mod(pos_all(:, 2), L_y);
    spd_all = spd_all + acc_all * dt;
    T_curr = T_curr + dt;
end

% Какую-то постобработку тоже нужно написать